package day2.tests;

import day2.Day2Part2Optimized;
import org.junit.jupiter.api.Test;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import static org.junit.jupiter.api.Assertions.*;

public class Day2Part2Tests {

    @Test
    public void testGenerator_SimpleRepetition() {
        // Test range [10, 100]
        // Should find 11, 22, ..., 99
        Day2Part2Optimized.InvalidIDGenerator generator = new Day2Part2Optimized.InvalidIDGenerator.Builder()
                .withMin(10)
                .withMax(100)
                .build();

        Set<Long> generated = ConcurrentHashMap.newKeySet();
        generator.generateInParallel(generated::add);

        assertTrue(generated.contains(11L));
        assertTrue(generated.contains(99L));
        assertFalse(generated.contains(10L));
        assertFalse(generated.contains(100L)); // 100 is not periodic
    }

    @Test
    public void testGenerator_ComplexRepetition() {
        // Test range [1000, 2000]
        // Should find 1212 (seed 12), 1010 (seed 10)
        Day2Part2Optimized.InvalidIDGenerator generator = new Day2Part2Optimized.InvalidIDGenerator.Builder()
                .withMin(1000)
                .withMax(2000)
                .build();

        Set<Long> generated = ConcurrentHashMap.newKeySet();
        generator.generateInParallel(generated::add);

        assertTrue(generated.contains(1212L));
        assertTrue(generated.contains(1010L));
        assertFalse(generated.contains(1234L));
    }

    @Test
    public void testGenerator_TripleRepetition() {
        // Test range [100, 1000]
        // Should find 111 (seed 1 repeated 3 times), 123123 (seed 123 repeated 2 times
        // - wait, 123123 > 1000)
        // 121212 (seed 12 repeated 3 times) -> > 1000
        // 111 -> seed 1, len 1. 1 -> 11 -> 111.

        Day2Part2Optimized.InvalidIDGenerator generator = new Day2Part2Optimized.InvalidIDGenerator.Builder()
                .withMin(100)
                .withMax(1000)
                .build();

        Set<Long> generated = ConcurrentHashMap.newKeySet();
        generator.generateInParallel(generated::add);

        assertTrue(generated.contains(111L)); // 1 repeated 3 times
        assertTrue(generated.contains(555L));

        // Let's check boundary
        assertFalse(generated.contains(1212L));
    }

    @Test
    public void testGenerator_Overlap() {
        // 1111 can be generated by seed 1 (1->11->111->1111) and seed 11 (11->1111)
        // The Set should handle uniqueness, but let's verify we generate it.
        Day2Part2Optimized.InvalidIDGenerator generator = new Day2Part2Optimized.InvalidIDGenerator.Builder()
                .withMin(1110)
                .withMax(1112)
                .build();

        Set<Long> generated = ConcurrentHashMap.newKeySet();
        generator.generateInParallel(generated::add);

        assertTrue(generated.contains(1111L));
        assertEquals(1, generated.size());
    }
}
