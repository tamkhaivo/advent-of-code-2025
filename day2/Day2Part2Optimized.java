package day2;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import java.util.function.LongConsumer;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Solves Day 2 Part 2 using an optimized generative approach with
 * multithreading.
 */
public class Day2Part2Optimized {

    private static final Logger logger = LogManager.getLogger(Day2Part2Optimized.class);
    private static final String FILE_PATH = "day2/day2.txt";

    public static void main(String[] args) {
        logger.info("Starting Day 2 Part 2 Optimized calculation.");
        long totalInvalidIDs = solve(FILE_PATH);
        System.out.println(totalInvalidIDs);
        logger.info("Calculation completed. Result: {}", totalInvalidIDs);
    }

    public static long solve(String filePath) {
        Optional<List<Range>> rangesResult = readRanges(filePath);

        if (rangesResult.isEmpty()) {
            logger.error("Failed to read ranges from file: {}", filePath);
            return 0;
        }

        List<Range> ranges = rangesResult.get();
        if (ranges.isEmpty()) {
            logger.warn("No ranges found.");
            return 0;
        }

        return calculateTotalInvalidIDs(ranges);
    }

    /**
     * Calculates the sum of all invalid IDs within the given ranges.
     * Uses a generative approach: generates potential invalid IDs and checks if
     * they fall in the ranges.
     *
     * @param ranges The list of ranges to check against.
     * @return The sum of invalid IDs.
     */
    private static long calculateTotalInvalidIDs(List<Range> ranges) {
        long min = Long.MAX_VALUE;
        long max = Long.MIN_VALUE;
        for (Range range : ranges) {
            if (range.start < min)
                min = range.start;
            if (range.end > max)
                max = range.end;
        }

        if (min > max)
            return 0;

        logger.debug("Generating invalid IDs between {} and {}", min, max);

        // Use a ConcurrentHashMap KeySet to store unique invalid IDs to avoid double
        // counting
        // (e.g. 1111 generated by seed 1 and seed 11)
        Set<Long> uniqueInvalidIDs = ConcurrentHashMap.newKeySet();

        InvalidIDGenerator generator = new InvalidIDGenerator.Builder()
                .withMin(min)
                .withMax(max)
                .build();

        // Execute generation in parallel
        generator.generateInParallel(uniqueInvalidIDs::add);

        // Sum up the valid ones
        return uniqueInvalidIDs.stream()
                .filter(id -> {
                    for (Range range : ranges) {
                        if (range.contains(id)) {
                            return true;
                        }
                    }
                    return false;
                })
                .mapToLong(Long::longValue)
                .sum();
    }

    /**
     * Reads ranges from the input file.
     *
     * @param filePath The path to the file.
     * @return An Optional containing the list of ranges, or empty if an error
     *         occurred.
     */
    private static Optional<List<Range>> readRanges(String filePath) {
        List<Range> ranges = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(",");
                for (String part : parts) {
                    try {
                        String[] bounds = part.split("-");
                        if (bounds.length == 2) {
                            long start = Long.parseLong(bounds[0]);
                            long end = Long.parseLong(bounds[1]);
                            ranges.add(new Range(start, end));
                        }
                    } catch (NumberFormatException e) {
                        logger.warn("Skipping invalid range format: {}", part);
                    }
                }
            }
            return Optional.of(ranges);
        } catch (IOException e) {
            logger.error("IOException reading file: {}", e.getMessage());
            return Optional.empty();
        }
    }

    /**
     * Value Object representing a numeric range.
     */
    public record Range(long start, long end) {
        public boolean contains(long value) {
            return value >= start && value <= end;
        }
    }

    /**
     * Domain Service for generating invalid IDs.
     * An invalid ID for Part 2 is a number formed by repeating a sequence of digits
     * at least twice (e.g., 1212, 123123, 555).
     */
    public static class InvalidIDGenerator {
        private final long min;
        private final long max;

        private InvalidIDGenerator(long min, long max) {
            this.min = min;
            this.max = max;
        }

        /**
         * Generates invalid IDs in parallel.
         * 
         * @param action The consumer to accept generated IDs.
         */
        public void generateInParallel(LongConsumer action) {
            int maxDigits = String.valueOf(max).length();
            // Max seed length is maxDigits / 2.
            // Example: if max is 1000 (4 digits), max seed len is 2 (seed 10 -> 1010).
            // If max is 100 (3 digits), max seed len is 1 (seed 1 -> 11).
            int maxSeedLength = maxDigits / 2;

            ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());

            for (int L = 1; L <= maxSeedLength; L++) {
                final int seedLength = L;
                executor.submit(() -> generateForSeedLength(seedLength, action));
            }

            executor.shutdown();
            try {
                if (!executor.awaitTermination(1, TimeUnit.MINUTES)) {
                    logger.warn("Executor did not terminate in time.");
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }

        private void generateForSeedLength(int seedLength, LongConsumer action) {
            long startSeed = (long) Math.pow(10, seedLength - 1);
            long endSeed = (long) Math.pow(10, seedLength) - 1;

            for (long seed = startSeed; seed <= endSeed; seed++) {
                long currentVal = seed;
                long multiplier = (long) Math.pow(10, seedLength);

                // We need at least 2 repetitions
                // First repetition:
                if (Long.MAX_VALUE / multiplier < currentVal)
                    break; // Overflow check
                currentVal = currentVal * multiplier + seed;

                while (currentVal <= max) {
                    if (currentVal >= min) {
                        action.accept(currentVal);
                    }

                    // Prepare next repetition
                    // Check for overflow before multiplying
                    if (Long.MAX_VALUE / multiplier < currentVal)
                        break;

                    long nextVal = currentVal * multiplier + seed;

                    // Check if we actually grew (overflow check part 2)
                    if (nextVal <= currentVal)
                        break;

                    currentVal = nextVal;
                }
            }
        }

        public static class Builder {
            private long min = 0;
            private long max = Long.MAX_VALUE;

            public Builder withMin(long min) {
                this.min = min;
                return this;
            }

            public Builder withMax(long max) {
                this.max = max;
                return this;
            }

            public InvalidIDGenerator build() {
                return new InvalidIDGenerator(min, max);
            }
        }
    }
}
